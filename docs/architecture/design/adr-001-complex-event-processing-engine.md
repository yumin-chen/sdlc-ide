# ADR-001: Complex Event Processing Engine

*   **Status**: Proposed
*   **Date**: 2025-11-27
*   **Deciders**: Jules
*   **Technical Story**: To build a high-performance, low-latency CEP engine for the Event-Based Observer Layer.

## Context and Problem Statement

The SDLC_IDE architecture relies on an Event-Based Observer Layer to provide insights and drive AI-assisted features. To effectively analyze the high-volume event streams generated by the Core DAG and Mesh extensions, we require a sophisticated Complex Event Processing (CEP) engine. This engine must be capable of identifying complex patterns, managing out-of-order events, and handling late-arriving data to ensure both correctness and performance.

The primary challenge is to design a system that balances correctness, latency, and resource consumption. An overly strict system may introduce unacceptable latency, while a lenient one might produce incorrect results. This ADR defines the core mechanics of the CEP engine, including the NFA instance lifecycle and the watermark-based strategy for managing event time.

## Decision Drivers

*   **Correctness**: The CEP engine must produce accurate results even when events are out-of-order.
*   **Performance**: The engine must be able to handle a high throughput of events with low latency.
*   **Resource Management**: The engine must have a clear strategy for managing state and preventing memory leaks (state explosion).
*   **Configurability**: The trade-offs between latency and correctness should be configurable to adapt to different use cases.

## Considered Options

*   **Custom Build**: A custom-built CEP engine tailored to the specific needs of the SDLC_IDE.
*   **Off-the-shelf Solution**: Integrating an existing open-source CEP engine like Apache Flink or Siddhi.

This ADR focuses on the design of a custom-built engine, but the principles outlined here can be applied to the configuration of an off-the-shelf solution as well.

## Decision

We will implement a custom CEP engine based on a Nondeterministic Finite Automaton (NFA) model. The engine will manage event time using a watermark mechanism and a temporal buffer to handle out-of-order and late events. The key components of this decision are detailed below.

### 1. NFA Instance Lifecycle: Creation, Progression, and Eviction

The NFA (Nondeterministic Finite Automaton) is the compiled, executable form of a declarative CEP pattern. An NFA Instance represents a specific, ongoing, partial match of that pattern sequence, usually tied to a specific key (e.g., a user session).

#### A. Instance Creation (Start)

*   **Incoming Event**: An event, say Event E_1, arrives and is processed.
*   **Start State Transition**: If E_1 satisfies the predicate for the very first step of the pattern (the Start State), a new NFA Instance is created for that specific E_1.
*   **State Storage**: This new instance stores a reference to E_1 and moves its internal pointer to the next state (e.g., In-A).

#### B. Instance Progression (Match & Advance)

*   **Subsequent Events**: A subsequent event, E_2, arrives and is fed to the NFA (in **Event Time** order, thanks to the temporal buffer).
*   **Transition Check**: The active NFA Instance checks if E_2 satisfies a transition predicate from its current state (e.g., the transition from In-A to In-B).
*   **Advancement**: If satisfied, E_2 is appended to the partial match sequence, and the instance moves to the next state (e.g., In-B).
*   **Completion**: If the instance reaches the Final State, a full pattern match is emitted. The engine then uses the configured Consumption Policy (e.g., SKIP_TO_NEXT) to decide whether to delete this instance or let it continue looking for overlapping matches.

#### C. Instance Eviction (Timeout)

*   **Timer Setting**: If the pattern includes a temporal constraint, such as `A -> B within 5 minutes`, an Event-Time Timer is scheduled when the instance transitions to state In-B. This timer is set for **EventTime(E_A) + 5 minutes**.
*   **Watermark Firing**: The timer does not fire by wall clock. It fires only when the Watermark (W) advances past the timer's set time.
*   **Timeout**: When the timer fires, the CEP engine concludes that the required event (e.g., B) will not arrive in time. The partial match is considered expired (a TIMEOUT or ABSENCE event may be emitted), and the NFA Instance is evicted (deleted) to free up memory. This is critical for preventing memory leaks (state explosion).

### 2. Handling Late and Out-of-Order Events

The entire out-of-order mechanism hinges on separating **Event Time** from **Processing Time** using Watermarks and the Temporal Buffer.

#### Out-of-Order Correction

*   **Mechanism**: The Temporal Buffer holds all incoming events and ensures that the NFA only sees events in strict **Event Time** order.
*   **Example**: If E_B (Event Time t=10:01) arrives physically before E_A (Event Time t=10:00):
    *   Both events enter the buffer.
    *   When the Watermark advances past t=10:01, the buffer releases E_A first, then E_B, maintaining the correct sequence order for the NFA.

#### Lateness Management (The Trade-Off)

The **Watermark** definition and the **Lateness Threshold** control how the system handles events that are significantly delayed.

*   **Watermark Strategy**: The W is often set with a bounded out-of-orderness delay (L) (e.g., W = Max Observed Event Time - L). This delay L is a safety margin that gives delayed events time to arrive before W commits the results.
*   **Late Event Policy**:
    *   An event is **Late** if **EventTime < Current Watermark**.
    *   An event is **Too Late** if **EventTime < (Current Watermark - Lateness Threshold)**.
*   **Resolution**: Events that are **Too Late** are handled based on policy:
    *   **Discarded**: If the latency/memory cost is too high.
    *   **DLQ**: Sent to a separate stream for retrospective analysis.

This dynamic system forces a core trade-off:

*   **Large L (High Lateness Tolerance)**: Higher confidence in correctness, but higher latency (must wait longer for W to advance) and higher memory usage (buffer must hold more events).
*   **Small L (Low Lateness Tolerance)**: Lower latency, but higher risk of dropping or missing late events, potentially leading to incorrect pattern matches.

## Consequences

### Positive

*   **Correctness by Design**: The use of watermarks and a temporal buffer ensures that the CEP engine produces correct results even with out-of-order events.
*   **State Management**: The instance eviction mechanism prevents memory leaks and ensures that the engine can run for long periods without issue.
*   **Configurability**: The trade-offs between latency and correctness can be tuned to meet the needs of different applications.

### Negative

*   **Increased Latency**: The watermark delay introduces a small amount of latency to the system.
*   **Increased Complexity**: The implementation of the CEP engine is more complex than a simple event processor.
*   **Memory Usage**: The temporal buffer will consume memory to store events that are waiting to be processed.

## Open Questions

*   What is the optimal default lateness threshold (L)?
*   How will the consumption policies (e.g., SKIP_TO_NEXT) be implemented?
*   What monitoring and alerting will be in place to track the health of the CEP engine?
