# ADR-001: Complex Event Processing Engine

*   **Status**: Implemented (Prototype)
*   **Date**: 2025-11-27
*   **Deciders**: Jules
*   **Technical Story**: To build a high-performance, low-latency CEP engine for the Event-Based Observer Layer.

**Supporting Documents**:
*   For concrete implementation examples, see the [CEP Implementation Guide](../../implementation/cep-examples-and-comparison.md).
*   For a detailed technical breakdown of the engine's internals, see the [CEP Internal Mechanics Deep Dive](../../implementation/cep-internal-mechanics.md).

## 1. Context and Problem Statement

The SDLC_IDE architecture relies on an Event-Based Observer Layer to provide insights and drive AI-assisted features. To effectively analyze the high-volume event streams generated by the Core DAG and Mesh extensions, we require a sophisticated Complex Event Processing (CEP) engine. This engine must be capable of identifying complex patterns, managing out-of-order events, and handling late-arriving data to ensure both correctness and performance.

## 2. Implementation Status

This ADR describes the complete architecture for a production-grade CEP engine. The initial implementation provides a solid foundation but is currently at a **prototype** stage. The following table clarifies the status of the key features:

| Feature                       | Status        | Notes                                                               |
| ----------------------------- | ------------- | ------------------------------------------------------------------- |
| Core Data Models              | Implemented   | `Event`, `Pattern`, `State`, `Match` classes are in place.          |
| Per-Key Temporal Buffer       | Implemented   | Handles out-of-order events on a per-key basis.                     |
| Watermark Generation          | Implemented   | Uses `max(eventTime) - outOfOrderness` strategy.                    |
| NFA Instance Management       | Implemented   | Core logic for creating and advancing partial matches is functional.|
| Event-Time Timers (`within`)  | Implemented   | NFA instances are correctly evicted based on temporal constraints.  |
| Consumption Policies          | Implemented   | `SKIP_TO_NEXT` and `SKIP_PAST_LAST_EVENT` are functional.           |
| `oneOrMore()` Quantifier      | Implemented   | Basic branching for greedy patterns is supported.                   |
| Late-Event Handling           | **Future Work** | The engine does not yet support `allowedLateness` or retractions.   |
| Advanced Quantifiers          | **Future Work** | `optional()`, `zeroOrMore()` are not yet implemented.               |
| State Checkpointing           | **Future Work** | The engine is in-memory only and not yet fault-tolerant.            |
| Memory Management Optimizations | **Future Work** | Does not yet include off-heap storage or memory budgets.            |

## 3. Decision

We will implement a custom CEP engine based on a Nondeterministic Finite Automaton (NFA) model. The engine will manage event time using a watermark mechanism and a temporal buffer to handle out-of-order and late events.

## 4. Core Principles

*   **NFA Instance Branching**: To handle greedy patterns, the engine tracks all possible partial matches simultaneously.
*   **Event-Time Timers**: `within()` clauses are enforced by scheduling timers that are triggered by the watermark to evict expired instances.
*   **Watermark-Driven Processing**: A temporal buffer orders events, releasing them only when the watermark advances, ensuring the NFA never sees out-of-order events.
*   **Late-Event Handling**: A configurable `allowedLateness` period allows the engine to process late events, potentially triggering corrections.
*   **Consumption Policies**: Policies like `SKIP_TO_NEXT` control state pruning after a match is found.

## 5. Non-Functional Requirements (NFRs)

The following are target constraints for the production-ready version of the CEP engine:

*   **Throughput Target**: >= 10,000 events/sec per core for typical patterns.
*   **Max Evaluation Latency**: < 10 ms p99 from event release to match emission.
*   **Max Allowed Out-of-Order Lateness**: Configurable, with a default of 5 seconds.
*   **Memory Ceiling per NFA Instance**: Target < 1 KB per instance, to be enforced by memory budgets.
*   **Watermark Propagation Latency**: The gap between wall-clock time and the current watermark should be monitored, with alerts firing if it exceeds 60 seconds.

## 6. Observability and Operational Model

A CEP engine must be highly observable to be operated reliably. The following metrics and behaviors are required:

*   **Metrics**:
    *   `cep_nfa_instances_active` (Gauge): A per-pattern count of active partial matches.
    *   `cep_memory_usage_bytes` (Gauge): Total estimated memory consumed by NFA instances and buffers.
    *   `cep_watermark_lag_seconds` (Gauge): The current gap between wall-clock time and the event-time watermark.
    *   `cep_events_processed_total` (Counter): Total events processed by the NFA engine.
    *   `cep_events_late_total` (Counter): Events arriving after the watermark but within `allowedLateness`.
    *   `cep_events_dropped_total` (Counter): Events arriving after `allowedLateness` ("too late").
    *   `cep_matches_emitted_total` (Counter): Total successful pattern matches emitted.
    *   `cep_retractions_emitted_total` (Counter): Total corrections emitted due to late events.
*   **Overload Behavior**: If memory usage exceeds the configured budget, the engine must shed load gracefully. The primary strategy will be to reduce `maxOutOfOrderness` temporarily to flush buffers more aggressively, followed by targeted eviction of the keys with the highest number of active NFA instances.

## 7. Late and Too-Late Event Policy

The engine's policy for handling late events must be explicit:

*   **Late Events** ( `eventTime > watermark` but `eventTime > watermark - allowedLateness`):
    *   These events will be processed, and may cause the engine to re-evaluate previously completed windows.
    *   If a re-evaluation results in a different outcome, the engine **must** emit a **retraction** for the original match and a new event for the corrected match.
*   **Too-Late Events** ( `eventTime <= watermark - allowedLateness`):
    *   These events **must be dropped**.
    *   A metric (`cep_events_dropped_total`) will be incremented.
    *   A log message at `WARN` level will be generated, including the event key and its timestamp vs. the current watermark.
    *   The event may optionally be routed to a Dead Letter Queue (DLQ) for offline analysis.

## 8. Testing Strategy

The complexity of the engine necessitates a multi-layered testing strategy:

*   **Unit Tests**: For individual components like the `SharedEventBuffer` (verifying reference counting) and `Pattern` builder.
*   **Integration Tests**: For the `CepEngine`, covering:
    *   Deterministic, in-order delivery and matching.
    *   Out-of-order scenarios with varying lateness windows.
    *   Correct watermark progression and its effect on event release.
    *   State eviction for patterns with `within()` clauses.
    *   Correct behavior of all consumption policies.
*   **Load Tests**: To validate NFRs, including high-frequency event ingestion and high-cardinality key space.
*   **Fault Tolerance Tests**: (Future Work) To verify state recovery from checkpoints.

## 9. Versioning and Compatibility

As patterns evolve, backward compatibility must be considered:

*   **Pattern Versioning**: All defined patterns must have a version number (e.g., `user_login_v1`, `user_login_v2`).
*   **Breaking Changes**: Any change to a pattern's logic that is not purely additive is considered a breaking change. The modified pattern must be deployed with a new version number.
*   **Replayability**: State is not guaranteed to be compatible across breaking pattern changes. For long-running patterns, a migration strategy or a "blue-green" deployment of the new pattern alongside the old one will be required.
